<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8" />
        <title>Fluid Drag Interaction</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Oswald:wght@200..700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                color-scheme: dark;
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0;
                min-height: 100vh;
                background: radial-gradient(
                    circle at 30% 20%,
                    #1f3b4d,
                    #050914
                );
                font-family: "Pretendard", "Noto Sans KR", sans-serif;
                overflow: hidden;
                color: #e8f6ff;
            }
            canvas {
                position: fixed;
                inset: 0;
                width: 100vw;
                height: 100vh;
                display: block;
                z-index: 5;
            }
            .title-text {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 80px;
                font-family: "Montserrat", "Oswald", sans-serif;
                font-weight: 800;
                color: #fff;
                letter-spacing: 0.2em;
                pointer-events: none;
                z-index: 10;
                text-transform: uppercase;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
                    0 0 40px rgba(255, 255, 255, 0.6),
                    0 0 60px rgba(255, 255, 255, 0.4),
                    0 4px 8px rgba(0, 0, 0, 0.5), 0 8px 16px rgba(0, 0, 0, 0.3);
                -webkit-text-stroke: 1px rgba(255, 255, 255, 0.2);
                filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.6));
                animation: titlePulse 2s ease-in-out infinite;
            }
            @keyframes titlePulse {
                0%,
                100% {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
                50% {
                    opacity: 0.9;
                    transform: translate(-50%, -50%) scale(1.02);
                }
            }
            .close-btn {
                position: fixed;
                top: 20px;
                right: 30px;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                border: none;
                background: rgba(0, 0, 0, 0.45);
                color: #e8f6ff;
                font-size: 28px;
                cursor: pointer;
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.2s ease, background 0.2s ease;
                z-index: 30;
            }
            .close-btn:hover {
                transform: scale(1.05);
                background: rgba(20, 30, 50, 0.7);
            }
        </style>
    </head>
    <body>
        <canvas id="fluidCanvas"></canvas>
        <div class="title-text">DRAG-IT!</div>

        <script>
            const canvas = document.getElementById("fluidCanvas");
            const ctx = canvas.getContext("2d");

            function resize() {
                const { width, height } = canvas.getBoundingClientRect();
                const ratio = window.devicePixelRatio || 1;
                canvas.width = width * ratio;
                canvas.height = height * ratio;
                ctx.scale(ratio, ratio);
            }
            resize();
            window.addEventListener("resize", resize);

            const fluidNodes = [];
            const COLORS = [
                "#6dd5ed",
                "#2193b0",
                "#00c6ff",
                "#85ffbd",
                "#f4d03f",
            ];
            const MAX_NODES = 550;
            const HISTORY_LENGTH = 10;
            const VISCOSITY = 0.88;
            const GRAVITY = 0.035;
            const FLOW_SWIRL = 0.12;

            let isDrawing = false;
            let lastPoint = null;

            function addFluidNode(x, y, vx = 0, vy = 0) {
                fluidNodes.push({
                    x,
                    y,
                    vx,
                    vy,
                    age: 0,
                    life: 160 + Math.random() * 120,
                    radius: 12 + Math.random() * 16,
                    color: COLORS[Math.floor(Math.random() * COLORS.length)],
                    history: [],
                    swirlSeed: Math.random() * Math.PI * 2,
                });
                if (fluidNodes.length > MAX_NODES) {
                    fluidNodes.splice(0, fluidNodes.length - MAX_NODES);
                }
            }

            function pointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top,
                };
            }

            function pointerDown(e) {
                isDrawing = true;
                lastPoint = pointerPos(e);
                addFluidNode(lastPoint.x, lastPoint.y);
            }

            function pointerMove(e) {
                if (!isDrawing) return;
                const point = pointerPos(e);
                if (!lastPoint) lastPoint = point;
                const dx = point.x - lastPoint.x;
                const dy = point.y - lastPoint.y;
                const dist = Math.hypot(dx, dy);
                const steps = Math.ceil(dist / 12);
                for (let i = 0; i < steps; i++) {
                    const t = i / steps;
                    const x = lastPoint.x + dx * t;
                    const y = lastPoint.y + dy * t;
                    const vx = dx * 0.03;
                    const vy = dy * 0.03;
                    addFluidNode(x, y, vx, vy);
                }
                lastPoint = point;
            }

            function pointerUp() {
                isDrawing = false;
                lastPoint = null;
            }

            canvas.addEventListener("mousedown", pointerDown);
            window.addEventListener("mousemove", pointerMove);
            window.addEventListener("mouseup", pointerUp);
            canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                pointerDown(e);
            });
            window.addEventListener("touchmove", (e) => {
                if (!isDrawing) return;
                e.preventDefault();
                pointerMove(e);
            });
            window.addEventListener("touchend", (e) => {
                e.preventDefault();
                pointerUp(e);
            });

            function animate() {
                ctx.fillStyle = "rgba(3, 6, 15, 0.18)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.globalCompositeOperation = "lighter";
                for (let i = fluidNodes.length - 1; i >= 0; i--) {
                    const node = fluidNodes[i];
                    node.age += 1;
                    const swirl =
                        Math.sin(node.age * 0.05 + node.swirlSeed) * FLOW_SWIRL;
                    node.vx = node.vx * VISCOSITY + Math.cos(swirl) * 0.05;
                    node.vy =
                        node.vy * VISCOSITY + GRAVITY + Math.sin(swirl) * 0.03;
                    node.x += node.vx;
                    node.y += node.vy;
                    node.radius *= 0.996;
                    node.history.unshift({ x: node.x, y: node.y });
                    if (node.history.length > HISTORY_LENGTH)
                        node.history.pop();

                    const alpha = Math.max(
                        0,
                        1 - node.age / node.life - Math.random() * 0.12
                    );
                    const gradient = ctx.createRadialGradient(
                        node.x,
                        node.y,
                        0,
                        node.x,
                        node.y,
                        node.radius * 2
                    );
                    gradient.addColorStop(0, `${node.color}DD`);
                    gradient.addColorStop(0.6, `${node.color}33`);
                    gradient.addColorStop(1, "rgba(0,0,0,0)");
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius * 2, 0, Math.PI * 2);
                    ctx.fill();

                    if (node.history.length > 2) {
                        ctx.lineWidth = node.radius * 0.45;
                        ctx.strokeStyle = hexToRgba(node.color, alpha * 0.25);
                        ctx.beginPath();
                        ctx.moveTo(node.history[0].x, node.history[0].y);
                        for (let h = 1; h < node.history.length; h++) {
                            const pt = node.history[h];
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.stroke();
                    }

                    if (alpha <= 0 || node.radius < 0.5) {
                        fluidNodes.splice(i, 1);
                    }
                }
                ctx.restore();
                requestAnimationFrame(animate);
            }
            animate();

            function hexToRgba(hex, alpha = 1) {
                const trimmed = hex.replace("#", "");
                const bigint = parseInt(trimmed, 16);
                const r = (bigint >> 16) & 255;
                const g = (bigint >> 8) & 255;
                const b = bigint & 255;
                return `rgba(${r},${g},${b},${alpha})`;
            }
        </script>
    </body>
</html>
